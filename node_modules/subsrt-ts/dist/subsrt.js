import formats from "./format/index.js";
const clone = (obj) => JSON.parse(JSON.stringify(obj));
class Subsrt {
    constructor() {
        this.format = formats;
        /**
         * Gets a list of supported subtitle formats.
         */
        this.list = () => Object.keys(this.format);
        /**
         * Detects a subtitle format from the content.
         */
        this.detect = (content) => {
            const formats = this.list();
            for (let i = 0; i < formats.length; i++) {
                const f = formats[i];
                const handler = this.format[f];
                if (typeof handler === "undefined") {
                    continue;
                }
                if (typeof handler.detect !== "function") {
                    continue;
                }
                // Function 'detect' can return true or format name
                const d = handler.detect(content);
                if (d === true || d === f) {
                    return f;
                }
            }
            return "";
        };
        /**
         * Parses a subtitle content.
         */
        this.parse = (content, options = {}) => {
            const format = options.format || this.detect(content);
            if (!format || format.trim().length === 0) {
                throw new Error("Cannot determine subtitle format!");
            }
            const handler = this.format[format];
            if (typeof handler === "undefined") {
                throw new Error(`Unsupported subtitle format: ${format}`);
            }
            const func = handler.parse;
            if (typeof func !== "function") {
                throw new Error(`Subtitle format does not support 'parse' op: ${format}`);
            }
            return func(content, options);
        };
        /**
         * Builds a subtitle content.
         */
        this.build = (captions, options = {}) => {
            const format = options.format || "srt";
            if (!format || format.trim().length === 0) {
                throw new Error("Cannot determine subtitle format!");
            }
            const handler = this.format[format];
            if (typeof handler === "undefined") {
                throw new Error(`Unsupported subtitle format: ${format}`);
            }
            const func = handler.build;
            if (typeof func !== "function") {
                throw new Error(`Subtitle format does not support 'build' op: ${format}`);
            }
            return func(captions, options);
        };
        /**
         * Converts subtitle format.
         */
        this.convert = (content, _options = {}) => {
            let options = {};
            if (typeof _options === "string") {
                options.to = _options;
            }
            else {
                options = _options;
            }
            const parseOptions = {
                format: options.from || undefined,
                verbose: options.verbose,
                eol: options.eol,
            };
            let captions = this.parse(content, parseOptions);
            if (options.resync) {
                captions = this.resync(captions, options.resync);
            }
            const buildOptions = {
                format: options.to || options.format,
                verbose: options.verbose,
                eol: options.eol,
            };
            const result = this.build(captions, buildOptions);
            return result;
        };
        /**
         * Shifts the time of the captions.
         */
        this.resync = (captions, options = {}) => {
            let func, ratio, frame = false, offset;
            if (typeof options === "function") {
                func = options; // User's function to handle time shift
            }
            else if (typeof options === "number") {
                offset = options; // Time shift (+/- offset)
                func = (a) => [a[0] + offset, a[1] + offset];
            }
            else if (typeof options === "object") {
                offset = (options.offset || 0) * (options.frame ? options.fps || 25 : 1);
                ratio = options.ratio || 1.0;
                frame = options.frame || false;
                func = (a) => [Math.round(a[0] * ratio + offset), Math.round(a[1] * ratio + offset)];
            }
            else {
                throw new Error("Argument 'options' not defined!");
            }
            const resynced = [];
            for (let i = 0; i < captions.length; i++) {
                const caption = clone(captions[i]);
                if (!caption.type || caption.type === "caption") {
                    if (frame) {
                        const shift = func([caption.frame.start, caption.frame.end]);
                        if (shift && shift.length === 2) {
                            caption.frame.start = shift[0];
                            caption.frame.end = shift[1];
                            caption.frame.count = caption.frame.end - caption.frame.start;
                        }
                    }
                    else {
                        const shift = func([caption.start, caption.end]);
                        if (shift && shift.length === 2) {
                            caption.start = shift[0];
                            caption.end = shift[1];
                            caption.duration = caption.end - caption.start;
                        }
                    }
                }
                resynced.push(caption);
            }
            return resynced;
        };
    }
}
const subsrt = new Subsrt();
export default subsrt;
export const { format, list, detect, parse, build, convert, resync } = subsrt;
