{
  "version": 3,
  "sources": ["../../subsrt-ts/dist/handler.js", "../../subsrt-ts/dist/format/ssa.js", "../../subsrt-ts/dist/format/ass.js", "../../subsrt-ts/dist/format/json.js", "../../subsrt-ts/dist/format/lrc.js", "../../subsrt-ts/dist/format/sbv.js", "../../subsrt-ts/dist/format/smi.js", "../../subsrt-ts/dist/format/srt.js", "../../subsrt-ts/dist/format/sub.js", "../../subsrt-ts/dist/format/vtt.js", "../../subsrt-ts/dist/format/index.js", "../../subsrt-ts/dist/subsrt.js"],
  "sourcesContent": ["export class Handler {\n    constructor({ name, build, detect, helper, parse }) {\n        this.name = name;\n        this.helper = helper;\n        this.build = build;\n        this.detect = (content) => {\n            if (typeof content !== \"string\") {\n                throw new Error(\"Expected string content!\");\n            }\n            return detect(content);\n        };\n        this.parse = (content, _options) => {\n            if (typeof content !== \"string\") {\n                throw new Error(\"Expected string content!\");\n            }\n            return parse(content, _options);\n        };\n    }\n}\nexport const buildHandler = (args) => {\n    return new Handler(args);\n};\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"ssa\";\nconst helper = {\n    toMilliseconds: (s) => {\n        const match = /^\\s*(\\d+:)?(\\d{1,2}):(\\d{1,2})(?:[.,](\\d{1,3}))?\\s*$/.exec(s);\n        if (!match) {\n            throw new Error(`Invalid time format: ${s}`);\n        }\n        const hh = match[1] ? parseInt(match[1].replace(\":\", \"\")) : 0;\n        const mm = parseInt(match[2]);\n        const ss = parseInt(match[3]);\n        const ff = match[4] ? parseInt(match[4]) : 0;\n        const ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff * 10;\n        return ms;\n    },\n    toTimeString: (ms) => {\n        const hh = Math.floor(ms / 1000 / 3600);\n        const mm = Math.floor((ms / 1000 / 60) % 60);\n        const ss = Math.floor((ms / 1000) % 60);\n        const ff = Math.floor((ms % 1000) / 10); // 2 digits\n        const time = `${hh}:${mm < 10 ? \"0\" : \"\"}${mm}:${ss < 10 ? \"0\" : \"\"}${ss}.${ff < 10 ? \"0\" : \"\"}${ff}`;\n        return time;\n    },\n};\n/**\n * Parses captions in SubStation Alpha format (.ssa).\n */\nconst parse = (content, options) => {\n    let meta;\n    let columns = null;\n    const captions = [];\n    const eol = options.eol || \"\\r\\n\";\n    const parts = content.split(/\\r?\\n\\s*\\n/);\n    for (let i = 0; i < parts.length; i++) {\n        const regex = /^\\s*\\[([^\\]]+)\\]\\r?\\n([\\s\\S]*)$/;\n        const match = regex.exec(parts[i]);\n        if (match) {\n            const tag = match[1];\n            const lines = match[2].split(/\\r?\\n/);\n            for (let l = 0; l < lines.length; l++) {\n                const line = lines[l];\n                if (/^\\s*;/.test(line)) {\n                    continue; // Skip comment\n                }\n                // FIXME: prevent backtracking\n                // eslint-disable-next-line regexp/no-super-linear-backtracking\n                const m = /^\\s*([^\\s:]+):\\s*(.*)$/.exec(line);\n                if (!m) {\n                    continue;\n                }\n                if (tag === \"Script Info\") {\n                    if (!meta) {\n                        meta = {};\n                        meta.type = \"meta\";\n                        meta.data = {};\n                        captions.push(meta);\n                    }\n                    if (typeof meta.data === \"object\") {\n                        const name = m[1].trim();\n                        const value = m[2].trim();\n                        meta.data[name] = value;\n                    }\n                    else {\n                        throw new Error(`Invalid meta data: ${line}`);\n                    }\n                }\n                else if (tag === \"V4 Styles\" || tag === \"V4+ Styles\") {\n                    const name = m[1].trim();\n                    const value = m[2].trim();\n                    if (name === \"Format\") {\n                        columns = value.split(/\\s*,\\s*/g);\n                    }\n                    else if (name === \"Style\" && columns) {\n                        const values = value.split(/\\s*,\\s*/g);\n                        const caption = {};\n                        caption.type = \"style\";\n                        caption.data = {};\n                        for (let c = 0; c < columns.length && c < values.length; c++) {\n                            caption.data[columns[c]] = values[c];\n                        }\n                        captions.push(caption);\n                    }\n                }\n                else if (tag === \"Events\") {\n                    const name = m[1].trim();\n                    const value = m[2].trim();\n                    if (name === \"Format\") {\n                        columns = value.split(/\\s*,\\s*/g);\n                    }\n                    else if (name === \"Dialogue\" && columns) {\n                        const values = value.split(/\\s*,\\s*/g);\n                        const caption = {};\n                        caption.type = \"caption\";\n                        caption.data = {};\n                        for (let c = 0; c < columns.length && c < values.length; c++) {\n                            caption.data[columns[c]] = values[c];\n                        }\n                        caption.start = helper.toMilliseconds(caption.data.Start);\n                        caption.end = helper.toMilliseconds(caption.data.End);\n                        caption.duration = caption.end - caption.start;\n                        caption.content = caption.data.Text;\n                        // Work-around for missing text (when the text contains ',' char)\n                        const getPosition = (s, search, index) => {\n                            return s.split(search, index).join(search).length;\n                        };\n                        const indexOfText = getPosition(value, \",\", columns.length - 1) + 1;\n                        caption.content = value.substring(indexOfText);\n                        caption.data.Text = caption.content;\n                        caption.text = caption.content\n                            .replace(/\\\\N/g, eol) // \"\\N\" for new line\n                            .replace(/\\{[^}]+\\}/g, \"\"); // {\\pos(400,570)}\n                        captions.push(caption);\n                    }\n                }\n            }\n        }\n        if (options.verbose) {\n            console.log(\"WARN: Unknown part\", parts[i]);\n        }\n    }\n    return captions;\n};\n/**\n * Builds captions in SubStation Alpha format (.ssa).\n */\nconst build = (captions, options) => {\n    const eol = options.eol || \"\\r\\n\";\n    const ass = options.format === \"ass\";\n    let content = \"\";\n    content += `[Script Info]${eol}`;\n    content += `; Script generated by subsrt ${eol}`;\n    content += `ScriptType: v4.00${ass ? \"+\" : \"\"}${eol}`;\n    content += `Collisions: Normal${eol}`;\n    content += eol;\n    if (ass) {\n        content += `[V4+ Styles]${eol}`;\n        content += `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding${eol}`;\n        content += `Style: DefaultVCD, Arial,28,&H00B4FCFC,&H00B4FCFC,&H00000008,&H80000008,-1,0,0,0,100,100,0.00,0.00,1,1.00,2.00,2,30,30,30,0${eol}`;\n    }\n    else {\n        content += `[V4 Styles]${eol}`;\n        content += `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding${eol}`;\n        content += `Style: DefaultVCD, Arial,28,11861244,11861244,11861244,-2147483640,-1,0,1,1,2,2,30,30,30,0,0${eol}`;\n    }\n    content += eol;\n    content += `[Events]${eol}`;\n    content += `Format: ${ass ? \"Layer\" : \"Marked\"}, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text${eol}`;\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n        if (caption.type === \"meta\") {\n            continue;\n        }\n        if (!caption.type || caption.type === \"caption\") {\n            content += `Dialogue: ${ass ? \"0\" : \"Marked=0\"},${helper.toTimeString(caption.start)},${helper.toTimeString(caption.end)},DefaultVCD, NTP,0000,0000,0000,,${caption.text.replace(/\\r?\\n/g, \"\\\\N\")}${eol}`;\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"SKIP:\", caption);\n        }\n    }\n    return content;\n};\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    if (/^\\s*\\[Script Info\\]\\r?\\n/.test(content) && /\\s*\\[Events\\]\\r?\\n/.test(content)) {\n        /*\n        [Script Info]\n        ...\n        [Events]\n        */\n        // Advanced (V4+) styles for ASS format\n        return content.indexOf(\"[V4+ Styles]\") > 0 ? \"ass\" : \"ssa\";\n    }\n    return false;\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });\nexport { FORMAT_NAME as name, build, detect, helper, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"ass\";\n// Compatible format\nimport { build, detect, helper, parse } from \"./ssa.js\";\nexport default buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });\nexport { FORMAT_NAME as name, build, detect, helper, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"json\";\n/**\n * Parses captions in JSON format.\n */\nconst parse = (content, _options) => JSON.parse(content);\n/**\n * Builds captions in JSON format.\n */\nconst build = (captions, _options) => JSON.stringify(captions, undefined, 2);\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    /*\n    [\n        { ... }\n    ]\n    */\n    // return /^\\[[\\s\\r\\n]*\\{[\\s\\S]*\\}[\\s\\r\\n]*\\]$/g.test(content);\n    try {\n        const res = JSON.parse(content);\n        return Array.isArray(res) && res.length > 0 && typeof res[0] === \"object\";\n    }\n    catch (e) {\n        return false;\n    }\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, parse });\nexport { FORMAT_NAME as name, build, detect, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"lrc\";\nconst helper = {\n    toMilliseconds: (s) => {\n        const match = /^\\s*(\\d+):(\\d{1,2})(?:[.,](\\d{1,3}))?\\s*$/.exec(s);\n        if (!match) {\n            throw new Error(`Invalid time format: ${s}`);\n        }\n        const mm = parseInt(match[1]);\n        const ss = parseInt(match[2]);\n        const ff = match[3] ? parseInt(match[3]) : 0;\n        const ms = mm * 60 * 1000 + ss * 1000 + ff * 10;\n        return ms;\n    },\n    toTimeString: (ms) => {\n        const mm = Math.floor(ms / 1000 / 60);\n        const ss = Math.floor((ms / 1000) % 60);\n        const ff = Math.floor(ms % 1000);\n        const time = `${(mm < 10 ? \"0\" : \"\") + mm}:${ss < 10 ? \"0\" : \"\"}${ss}.${ff < 100 ? \"0\" : \"\"}${ff < 10 ? \"0\" : Math.floor(ff / 10)}`;\n        return time;\n    },\n};\n/**\n * Parses captions in LRC format.\n * @see https://en.wikipedia.org/wiki/LRC_%28file_format%29\n */\nconst parse = (content, options) => {\n    let prev = null;\n    const captions = [];\n    // const eol = options.eol || \"\\r\\n\";\n    const parts = content.split(/\\r?\\n/);\n    for (let i = 0; i < parts.length; i++) {\n        if (!parts[i] || parts[i].trim().length === 0) {\n            continue;\n        }\n        // LRC content\n        const regex = /^\\[(\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\](.*)(?:\\r?\\n)*$/;\n        const match = regex.exec(parts[i]);\n        if (match) {\n            const caption = {};\n            caption.type = \"caption\";\n            caption.start = helper.toMilliseconds(match[1]);\n            caption.end = caption.start + 2000;\n            caption.duration = caption.end - caption.start;\n            caption.content = match[2];\n            caption.text = caption.content;\n            captions.push(caption);\n            // Update previous\n            if (prev) {\n                prev.end = caption.start;\n                prev.duration = prev.end - prev.start;\n            }\n            prev = caption;\n            continue;\n        }\n        // LRC meta\n        const meta = /^\\[(\\w+):([^\\]]*)\\](?:\\r?\\n)*$/.exec(parts[i]);\n        if (meta) {\n            const caption = {};\n            caption.type = \"meta\";\n            caption.tag = meta[1];\n            if (meta[2]) {\n                caption.data = meta[2];\n            }\n            captions.push(caption);\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"WARN: Unknown part\", parts[i]);\n        }\n    }\n    return captions;\n};\n/**\n * Builds captions in LRC format\n * @see https://en.wikipedia.org/wiki/LRC_%28file_format%29\n */\nconst build = (captions, options) => {\n    let content = \"\";\n    let lyrics = false;\n    const eol = options.eol || \"\\r\\n\";\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n        if (caption.type === \"meta\") {\n            if (caption.tag && caption.data && typeof caption.data === \"string\") {\n                content += `[${caption.tag}:${caption.data.replace(/[\\r\\n]+/g, \" \")}]${eol}`;\n            }\n            continue;\n        }\n        if (!caption.type || caption.type === \"caption\") {\n            if (!lyrics) {\n                content += eol; //New line when lyrics start\n                lyrics = true;\n            }\n            content += `[${helper.toTimeString(caption.start)}]${caption.text}${eol}`;\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"SKIP:\", caption);\n        }\n    }\n    return content;\n};\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    /*\n    [04:48.28]Sister, perfume?\n    */\n    return /\\r?\\n\\[\\d+:\\d{1,2}(?:[.,]\\d{1,3})?\\].*\\r?\\n/.test(content);\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });\nexport { FORMAT_NAME as name, build, detect, helper, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"sbv\";\nconst helper = {\n    toMilliseconds: (s) => {\n        const match = /^\\s*(\\d{1,2}):(\\d{1,2}):(\\d{1,2})(?:[.,](\\d{1,3}))?\\s*$/.exec(s);\n        if (!match) {\n            throw new Error(`Invalid time format: ${s}`);\n        }\n        const hh = parseInt(match[1]);\n        const mm = parseInt(match[2]);\n        const ss = parseInt(match[3]);\n        const ff = match[4] ? parseInt(match[4]) : 0;\n        const ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff;\n        return ms;\n    },\n    toTimeString: (ms) => {\n        const hh = Math.floor(ms / 1000 / 3600);\n        const mm = Math.floor((ms / 1000 / 60) % 60);\n        const ss = Math.floor((ms / 1000) % 60);\n        const ff = Math.floor(ms % 1000);\n        const time = `${(hh < 10 ? \"0\" : \"\") + hh}:${mm < 10 ? \"0\" : \"\"}${mm}:${ss < 10 ? \"0\" : \"\"}${ss}.${ff < 100 ? \"0\" : \"\"}${ff < 10 ? \"0\" : \"\"}${ff}`;\n        return time;\n    },\n};\n/**\n * Parses captions in SubViewer format (.sbv).\n */\nconst parse = (content, options) => {\n    const captions = [];\n    const eol = options.eol || \"\\r\\n\";\n    const parts = content.split(/\\r?\\n\\s*\\n/);\n    for (let i = 0; i < parts.length; i++) {\n        const regex = /^(\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\s*[,;]\\s*(\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\r?\\n([\\s\\S]*)$/;\n        const match = regex.exec(parts[i]);\n        if (match) {\n            const caption = {};\n            caption.type = \"caption\";\n            caption.start = helper.toMilliseconds(match[1]);\n            caption.end = helper.toMilliseconds(match[2]);\n            caption.duration = caption.end - caption.start;\n            const lines = match[3].split(/\\[br\\]|\\r?\\n/gi);\n            caption.content = lines.join(eol);\n            caption.text = caption.content.replace(/>>[^:]+:\\s*/g, \"\"); // >> SPEAKER NAME:\n            captions.push(caption);\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"WARN: Unknown part\", parts[i]);\n        }\n    }\n    return captions;\n};\n/**\n * Builds captions in SubViewer format (.sbv).\n */\nconst build = (captions, options) => {\n    let content = \"\";\n    const eol = options.eol || \"\\r\\n\";\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n        if (!caption.type || caption.type === \"caption\") {\n            content += `${helper.toTimeString(caption.start)},${helper.toTimeString(caption.end)}${eol}`;\n            content += caption.text + eol;\n            content += eol;\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"SKIP:\", caption);\n        }\n    }\n    return content;\n};\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    /*\n    00:04:48.280,00:04:50.510\n    Sister, perfume?\n    */\n    return /\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?\\s*[,;]\\s*\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?/.test(content);\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });\nexport { FORMAT_NAME as name, build, detect, helper, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"smi\";\nconst helper = {\n    htmlEncode: (text) => text\n        .replace(/&/g, \"&amp;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#39;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        //.replace(/\\s/g, '&nbsp;')\n        .replace(/\\r?\\n/g, \"<BR>\"),\n    htmlDecode: (html, eol) => html\n        .replace(/<BR\\s*\\/?>/gi, eol || \"\\r\\n\")\n        .replace(/&nbsp;/g, \" \")\n        .replace(/&quot;/g, '\"')\n        .replace(/&#39;/g, \"'\")\n        .replace(/&lt;/g, \"<\")\n        .replace(/&gt;/g, \">\")\n        .replace(/&amp;/g, \"&\"),\n};\n/**\n * Parses captions in SAMI format (.smi).\n */\nconst parse = (content, options) => {\n    if (options.format && options.format !== FORMAT_NAME) {\n        throw new Error(`Invalid format: ${options.format}`);\n    }\n    const captions = [];\n    const eol = options.eol || \"\\r\\n\";\n    const title = /<TITLE[^>]*>([\\s\\S]*)<\\/TITLE>/i.exec(content);\n    if (title) {\n        const caption = {};\n        caption.type = \"meta\";\n        caption.name = \"title\";\n        caption.data = title[1].replace(/^\\s*/g, \"\").replace(/\\s*$/g, \"\");\n        captions.push(caption);\n    }\n    const style = /<STYLE[^>]*>([\\s\\S]*)<\\/STYLE>/i.exec(content);\n    if (style) {\n        const caption = {};\n        caption.type = \"meta\";\n        caption.name = \"style\";\n        caption.data = style[1];\n        captions.push(caption);\n    }\n    const sami = content\n        .replace(/^[\\s\\S]*<BODY[^>]*>/gi, \"\") // Remove content before body\n        .replace(/<\\/BODY[^>]*>[\\s\\S]*$/gi, \"\"); // Remove content after body\n    let prev = null;\n    const parts = sami.split(/<SYNC/gi);\n    for (let i = 0; i < parts.length; i++) {\n        if (!parts[i] || parts[i].trim().length === 0) {\n            continue;\n        }\n        const part = `<SYNC${parts[i]}`;\n        // <SYNC Start = 1000>\n        const match = /^<SYNC[^>]+Start\\s*=\\s*[\"']?(\\d+)[^\\d>]*>([\\s\\S]*)/i.exec(part);\n        if (match) {\n            const caption = {};\n            caption.type = \"caption\";\n            caption.start = parseInt(match[1]);\n            caption.end = caption.start + 2000;\n            caption.duration = caption.end - caption.start;\n            caption.content = match[2].replace(/^<\\/SYNC[^>]*>/gi, \"\");\n            let blank = true;\n            const p = /^<P.+Class\\s*=\\s*[\"']?([\\w-]+)(?: .*)?>([\\s\\S]*)/i.exec(caption.content) || /^<P([^>]*)>([\\s\\S]*)/i.exec(caption.content);\n            if (p) {\n                let html = p[2].replace(/<P[\\s\\S]+$/gi, \"\"); // Remove string after another <P> tag\n                html = html\n                    .replace(/<BR\\s*\\/?>\\s+/gi, eol)\n                    .replace(/<BR\\s*\\/?>/gi, eol)\n                    .replace(/<[^>]+>/g, \"\"); // Remove all tags\n                html = html.replace(/^\\s+/g, \"\").replace(/\\s+$/g, \"\"); // Trim new lines and spaces\n                blank = html.replace(/&nbsp;/gi, \" \").replace(/\\s+/g, \"\").length === 0;\n                caption.text = helper.htmlDecode(html, eol);\n            }\n            if (!options.preserveSpaces && blank) {\n                if (options.verbose) {\n                    console.log(`INFO: Skipping white space caption at ${caption.start}`);\n                }\n            }\n            else {\n                captions.push(caption);\n            }\n            // Update previous\n            if (prev) {\n                prev.end = caption.start;\n                prev.duration = prev.end - prev.start;\n            }\n            prev = caption;\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"WARN: Unknown part\", parts[i]);\n        }\n    }\n    return captions;\n};\n/**\n * Builds captions in SAMI format (.smi).\n */\nconst build = (captions, options) => {\n    const eol = options.eol || \"\\r\\n\";\n    let content = \"\";\n    content += `<SAMI>${eol}`;\n    content += `<HEAD>${eol}`;\n    content += `<TITLE>${options.title || \"\"}</TITLE>${eol}`;\n    content += `<STYLE TYPE=\"text/css\">${eol}`;\n    content += `<!--${eol}`;\n    content += `P { font-family: Arial; font-weight: normal; color: white; background-color: black; text-align: center; }${eol}`;\n    content += `.LANG { Name: ${options.langName || \"English\"}; lang: ${options.langCode || \"en-US\"}; SAMIType: CC; }${eol}`;\n    content += `-->${eol}`;\n    content += `</STYLE>${eol}`;\n    content += `</HEAD>${eol}`;\n    content += `<BODY>${eol}`;\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n        if (caption.type === \"meta\") {\n            continue;\n        }\n        if (!caption.type || caption.type === \"caption\") {\n            // Start of caption\n            content += `<SYNC Start=${caption.start}>${eol}`;\n            content += `  <P Class=LANG>${helper.htmlEncode(caption.text || \"\")}${options.closeTags ? \"</P>\" : \"\"}${eol}`;\n            if (options.closeTags) {\n                content += `</SYNC>${eol}`;\n            }\n            // Blank line indicates the end of caption\n            content += `<SYNC Start=${caption.end}>${eol}`;\n            content += \"  <P Class=LANG>\" + `&nbsp;${options.closeTags ? \"</P>\" : \"\"}${eol}`;\n            if (options.closeTags) {\n                content += `</SYNC>${eol}`;\n            }\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"SKIP:\", caption);\n        }\n    }\n    content += `</BODY>${eol}`;\n    content += `</SAMI>${eol}`;\n    return content;\n};\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    /*\n    <SAMI>\n    <BODY>\n    <SYNC Start=...\n    ...\n    </BODY>\n    </SAMI>\n    */\n    return /<SAMI[^>]*>[\\s\\S]*<BODY[^>]*>/.test(content);\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });\nexport { FORMAT_NAME as name, build, detect, helper, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"srt\";\nconst helper = {\n    toMilliseconds: (s) => {\n        const match = /^\\s*(\\d{1,2}):(\\d{1,2}):(\\d{1,2})(?:[.,](\\d{1,3}))?\\s*$/.exec(s);\n        if (!match) {\n            throw new Error(`Invalid time format: ${s}`);\n        }\n        const hh = parseInt(match[1]);\n        const mm = parseInt(match[2]);\n        const ss = parseInt(match[3]);\n        const ff = match[4] ? parseInt(match[4]) : 0;\n        const ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff;\n        return ms;\n    },\n    toTimeString: (ms) => {\n        const hh = Math.floor(ms / 1000 / 3600);\n        const mm = Math.floor((ms / 1000 / 60) % 60);\n        const ss = Math.floor((ms / 1000) % 60);\n        const ff = Math.floor(ms % 1000);\n        const time = `${(hh < 10 ? \"0\" : \"\") + hh}:${mm < 10 ? \"0\" : \"\"}${mm}:${ss < 10 ? \"0\" : \"\"}${ss},${ff < 100 ? \"0\" : \"\"}${ff < 10 ? \"0\" : \"\"}${ff}`;\n        return time;\n    },\n};\n/**\n * Parses captions in SubRip format (.srt).\n */\nconst parse = (content, options) => {\n    const captions = [];\n    const eol = options.eol || \"\\r\\n\";\n    const parts = content.split(/\\r?\\n\\s*\\n/g);\n    for (let i = 0; i < parts.length; i++) {\n        const regex = /^(\\d+)\\r?\\n(\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\s*-->\\s*(\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\r?\\n([\\s\\S]*)$/;\n        const match = regex.exec(parts[i]);\n        if (match) {\n            const caption = {};\n            caption.type = \"caption\";\n            caption.index = parseInt(match[1]);\n            caption.start = helper.toMilliseconds(match[2]);\n            caption.end = helper.toMilliseconds(match[3]);\n            caption.duration = caption.end - caption.start;\n            const lines = match[4].split(/\\r?\\n/);\n            caption.content = lines.join(eol);\n            caption.text = caption.content\n                .replace(/<[^>]+>/g, \"\") // <b>bold</b> or <i>italic</i>\n                .replace(/\\{[^}]+\\}/g, \"\") // {b}bold{/b} or {i}italic{/i}\n                .replace(/>>[^:]*:\\s*/g, \"\"); // >> SPEAKER NAME:\n            captions.push(caption);\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"WARN: Unknown part\", parts[i]);\n        }\n    }\n    return captions;\n};\n/**\n * Builds captions in SubRip format (.srt).\n */\nconst build = (captions, options) => {\n    let srt = \"\";\n    const eol = options.eol || \"\\r\\n\";\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n        if (!caption.type || caption.type === \"caption\") {\n            srt += (i + 1).toString() + eol;\n            srt += `${helper.toTimeString(caption.start)} --> ${helper.toTimeString(caption.end)}${eol}`;\n            srt += caption.text + eol;\n            srt += eol;\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"SKIP:\", caption);\n        }\n    }\n    return srt;\n};\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    /*\n    3\n    00:04:48,280 --> 00:04:50,510\n    Sister, perfume?\n    */\n    return /\\d+\\r?\\n\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?\\s*-->\\s*\\d{1,2}:\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?/.test(content);\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });\nexport { FORMAT_NAME as name, build, detect, helper, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"sub\";\nconst DEFAULT_FPS = 25;\n/**\n * Parses captions in MicroDVD format.\n * @see https://en.wikipedia.org/wiki/MicroDVD\n */\nconst parse = (content, options) => {\n    options.fps || (options.fps = DEFAULT_FPS);\n    const fps = options.fps > 0 ? options.fps : DEFAULT_FPS;\n    const captions = [];\n    const eol = options.eol || \"\\r\\n\";\n    const parts = content.split(/\\r?\\n/g);\n    for (let i = 0; i < parts.length; i++) {\n        const regex = /^\\{(\\d+)\\}\\{(\\d+)\\}(.*)$/;\n        const match = regex.exec(parts[i]);\n        if (match) {\n            const caption = {};\n            caption.type = \"caption\";\n            caption.index = i + 1;\n            caption.frame = {\n                start: parseInt(match[1]),\n                end: parseInt(match[2]),\n                count: parseInt(match[2]) - parseInt(match[1]),\n            };\n            caption.start = Math.round(caption.frame.start / fps);\n            caption.end = Math.round(caption.frame.end / fps);\n            caption.duration = caption.end - caption.start;\n            const lines = match[3].split(/\\|/g);\n            caption.content = lines.join(eol);\n            caption.text = caption.content.replace(/\\{[^}]+\\}/g, \"\"); // {0}{25}{c:$0000ff}{y:b,u}{f:DeJaVuSans}{s:12}Hello!\n            captions.push(caption);\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"WARN: Unknown part\", parts[i]);\n        }\n    }\n    return captions;\n};\n/**\n * Builds captions in MicroDVD format.\n * @see https://en.wikipedia.org/wiki/MicroDVD\n */\nconst build = (captions, options) => {\n    const fps = (options.fps || 0) > 0 ? options.fps : DEFAULT_FPS;\n    let sub = \"\";\n    const eol = options.eol || \"\\r\\n\";\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n        if (!caption.type || caption.type === \"caption\") {\n            const startFrame = typeof caption.frame === \"object\" && caption.frame.start >= 0 ? caption.frame.start : caption.start * fps;\n            const endFrame = typeof caption.frame === \"object\" && caption.frame.end >= 0 ? caption.frame.end : caption.end * fps;\n            const text = caption.text.replace(/\\r?\\n/, \"|\");\n            sub += `{${startFrame}}` + `{${endFrame}}${text}${eol}`;\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"SKIP:\", caption);\n        }\n    }\n    return sub;\n};\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    /*\n    {7207}{7262}Sister, perfume?\n    */\n    return /^\\{\\d+\\}\\{\\d+\\}.*/.test(content);\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, parse });\nexport { FORMAT_NAME as name, build, detect, parse };\n", "import { buildHandler } from \"../handler.js\";\nconst FORMAT_NAME = \"vtt\";\nconst helper = {\n    toMilliseconds: (s) => {\n        const match = /^\\s*(\\d{1,2}:)?(\\d{1,2}):(\\d{1,2})(?:[.,](\\d{1,3}))?\\s*$/.exec(s);\n        if (!match) {\n            throw new Error(`Invalid time format: ${s}`);\n        }\n        const hh = match[1] ? parseInt(match[1].replace(\":\", \"\")) : 0;\n        const mm = parseInt(match[2]);\n        const ss = parseInt(match[3]);\n        const ff = match[4] ? parseInt(match[4]) : 0;\n        const ms = hh * 3600 * 1000 + mm * 60 * 1000 + ss * 1000 + ff;\n        return ms;\n    },\n    toTimeString: (ms) => {\n        const hh = Math.floor(ms / 1000 / 3600);\n        const mm = Math.floor((ms / 1000 / 60) % 60);\n        const ss = Math.floor((ms / 1000) % 60);\n        const ff = Math.floor(ms % 1000);\n        const time = `${(hh < 10 ? \"0\" : \"\") + hh}:${mm < 10 ? \"0\" : \"\"}${mm}:${ss < 10 ? \"0\" : \"\"}${ss}.${ff < 100 ? \"0\" : \"\"}${ff < 10 ? \"0\" : \"\"}${ff}`;\n        return time;\n    },\n};\n/**\n * Parses captions in WebVTT format (Web Video Text Tracks Format)\n */\nconst parse = (content, options) => {\n    let index = 1;\n    const captions = [];\n    const parts = content.split(/\\r?\\n\\s*\\n/);\n    for (const part of parts) {\n        // WebVTT data\n        const regex = /^([^\\r\\n]+\\r?\\n)?((?:\\d{1,2}:)?\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)\\s*-->\\s*((?:\\d{1,2}:)?\\d{1,2}:\\d{1,2}(?:[.,]\\d{1,3})?)[^\\S\\r\\n]?.*\\r?\\n([\\s\\S]*)$/;\n        const match = regex.exec(part);\n        if (match) {\n            const caption = {};\n            caption.type = \"caption\";\n            caption.index = index++;\n            if (match[1]) {\n                caption.cue = match[1].replace(/[\\r\\n]*/g, \"\");\n            }\n            caption.start = helper.toMilliseconds(match[2]);\n            caption.end = helper.toMilliseconds(match[3]);\n            caption.duration = caption.end - caption.start;\n            caption.content = match[4];\n            caption.text = caption.content\n                .replace(/<[^>]+>/g, \"\") // <b>bold</b> or <i>italic</i>\n                .replace(/\\{[^}]+\\}/g, \"\"); // {b}bold{/b} or {i}italic{/i}\n            captions.push(caption);\n            continue;\n        }\n        // WebVTT meta\n        // FIXME: prevent backtracking\n        // eslint-disable-next-line regexp/no-super-linear-backtracking\n        const meta = /^([A-Z]+)(\\r?\\n([\\s\\S]*))?$/.exec(part) || /^([A-Z]+)\\s+([^\\r\\n]*)$/.exec(part);\n        if (meta) {\n            const caption = {};\n            caption.type = \"meta\";\n            caption.name = meta[1];\n            if (meta[3]) {\n                caption.data = meta[3];\n            }\n            captions.push(caption);\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"WARN: Unknown part\", part);\n        }\n    }\n    return captions;\n};\n/**\n * Builds captions in WebVTT format (Web Video Text Tracks Format).\n */\nconst build = (captions, options) => {\n    const eol = options.eol || \"\\r\\n\";\n    let content = `WEBVTT${eol}${eol}`;\n    for (let i = 0; i < captions.length; i++) {\n        const caption = captions[i];\n        if (caption.type === \"meta\") {\n            if (caption.name === \"WEBVTT\") {\n                continue;\n            }\n            content += caption.name + eol;\n            content += caption.data ? caption.data + eol : \"\";\n            content += eol;\n            continue;\n        }\n        if (!caption.type || caption.type === \"caption\") {\n            content += (i + 1).toString() + eol;\n            content += `${helper.toTimeString(caption.start)} --> ${helper.toTimeString(caption.end)}${eol}`;\n            content += caption.text + eol;\n            content += eol;\n            continue;\n        }\n        if (options.verbose) {\n            console.log(\"SKIP:\", caption);\n        }\n    }\n    return content;\n};\n/**\n * Detects a subtitle format from the content.\n */\nconst detect = (content) => {\n    /*\n    WEBVTT\n    ...\n    */\n    return /^\\s*WEBVTT\\r?\\n/.test(content);\n};\nexport default buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });\nexport { FORMAT_NAME as name, build, detect, helper, parse };\n", "import ass from \"./ass.js\";\nimport json from \"./json.js\";\nimport lrc from \"./lrc.js\";\nimport sbv from \"./sbv.js\";\nimport smi from \"./smi.js\";\nimport srt from \"./srt.js\";\nimport ssa from \"./ssa.js\";\nimport sub from \"./sub.js\";\nimport vtt from \"./vtt.js\";\nconst formats = {\n    vtt,\n    lrc,\n    smi,\n    ssa,\n    ass,\n    sub,\n    srt,\n    sbv,\n    json,\n};\nexport default formats;\n", "import formats from \"./format/index.js\";\nconst clone = (obj) => JSON.parse(JSON.stringify(obj));\nclass Subsrt {\n    constructor() {\n        this.format = formats;\n        /**\n         * Gets a list of supported subtitle formats.\n         */\n        this.list = () => Object.keys(this.format);\n        /**\n         * Detects a subtitle format from the content.\n         */\n        this.detect = (content) => {\n            const formats = this.list();\n            for (let i = 0; i < formats.length; i++) {\n                const f = formats[i];\n                const handler = this.format[f];\n                if (typeof handler === \"undefined\") {\n                    continue;\n                }\n                if (typeof handler.detect !== \"function\") {\n                    continue;\n                }\n                // Function 'detect' can return true or format name\n                const d = handler.detect(content);\n                if (d === true || d === f) {\n                    return f;\n                }\n            }\n            return \"\";\n        };\n        /**\n         * Parses a subtitle content.\n         */\n        this.parse = (content, options = {}) => {\n            const format = options.format || this.detect(content);\n            if (!format || format.trim().length === 0) {\n                throw new Error(\"Cannot determine subtitle format!\");\n            }\n            const handler = this.format[format];\n            if (typeof handler === \"undefined\") {\n                throw new Error(`Unsupported subtitle format: ${format}`);\n            }\n            const func = handler.parse;\n            if (typeof func !== \"function\") {\n                throw new Error(`Subtitle format does not support 'parse' op: ${format}`);\n            }\n            return func(content, options);\n        };\n        /**\n         * Builds a subtitle content.\n         */\n        this.build = (captions, options = {}) => {\n            const format = options.format || \"srt\";\n            if (!format || format.trim().length === 0) {\n                throw new Error(\"Cannot determine subtitle format!\");\n            }\n            const handler = this.format[format];\n            if (typeof handler === \"undefined\") {\n                throw new Error(`Unsupported subtitle format: ${format}`);\n            }\n            const func = handler.build;\n            if (typeof func !== \"function\") {\n                throw new Error(`Subtitle format does not support 'build' op: ${format}`);\n            }\n            return func(captions, options);\n        };\n        /**\n         * Converts subtitle format.\n         */\n        this.convert = (content, _options = {}) => {\n            let options = {};\n            if (typeof _options === \"string\") {\n                options.to = _options;\n            }\n            else {\n                options = _options;\n            }\n            const parseOptions = {\n                format: options.from || undefined,\n                verbose: options.verbose,\n                eol: options.eol,\n            };\n            let captions = this.parse(content, parseOptions);\n            if (options.resync) {\n                captions = this.resync(captions, options.resync);\n            }\n            const buildOptions = {\n                format: options.to || options.format,\n                verbose: options.verbose,\n                eol: options.eol,\n            };\n            const result = this.build(captions, buildOptions);\n            return result;\n        };\n        /**\n         * Shifts the time of the captions.\n         */\n        this.resync = (captions, options = {}) => {\n            let func, ratio, frame = false, offset;\n            if (typeof options === \"function\") {\n                func = options; // User's function to handle time shift\n            }\n            else if (typeof options === \"number\") {\n                offset = options; // Time shift (+/- offset)\n                func = (a) => [a[0] + offset, a[1] + offset];\n            }\n            else if (typeof options === \"object\") {\n                offset = (options.offset || 0) * (options.frame ? options.fps || 25 : 1);\n                ratio = options.ratio || 1.0;\n                frame = options.frame || false;\n                func = (a) => [Math.round(a[0] * ratio + offset), Math.round(a[1] * ratio + offset)];\n            }\n            else {\n                throw new Error(\"Argument 'options' not defined!\");\n            }\n            const resynced = [];\n            for (let i = 0; i < captions.length; i++) {\n                const caption = clone(captions[i]);\n                if (!caption.type || caption.type === \"caption\") {\n                    if (frame) {\n                        const shift = func([caption.frame.start, caption.frame.end]);\n                        if (shift && shift.length === 2) {\n                            caption.frame.start = shift[0];\n                            caption.frame.end = shift[1];\n                            caption.frame.count = caption.frame.end - caption.frame.start;\n                        }\n                    }\n                    else {\n                        const shift = func([caption.start, caption.end]);\n                        if (shift && shift.length === 2) {\n                            caption.start = shift[0];\n                            caption.end = shift[1];\n                            caption.duration = caption.end - caption.start;\n                        }\n                    }\n                }\n                resynced.push(caption);\n            }\n            return resynced;\n        };\n    }\n}\nconst subsrt = new Subsrt();\nexport default subsrt;\nexport const { format, list, detect, parse, build, convert, resync } = subsrt;\n"],
  "mappings": "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",
  "names": ["build", "detect", "helper", "parse", "FORMAT_NAME", "FORMAT_NAME", "parse", "build", "detect", "FORMAT_NAME", "helper", "parse", "build", "detect", "FORMAT_NAME", "helper", "parse", "build", "detect", "FORMAT_NAME", "helper", "parse", "build", "detect", "FORMAT_NAME", "helper", "parse", "build", "detect", "FORMAT_NAME", "parse", "build", "detect", "FORMAT_NAME", "helper", "parse", "build", "detect", "formats", "format", "detect", "parse", "build"]
}
