import "./chunk-WQG2LZMB.js";

// node_modules/subsrt-ts/dist/handler.js
var Handler = class {
  constructor({ name, build: build10, detect: detect10, helper: helper7, parse: parse10 }) {
    this.name = name;
    this.helper = helper7;
    this.build = build10;
    this.detect = (content) => {
      if (typeof content !== "string") {
        throw new Error("Expected string content!");
      }
      return detect10(content);
    };
    this.parse = (content, _options) => {
      if (typeof content !== "string") {
        throw new Error("Expected string content!");
      }
      return parse10(content, _options);
    };
  }
};
var buildHandler = (args) => {
  return new Handler(args);
};

// node_modules/subsrt-ts/dist/format/ssa.js
var FORMAT_NAME = "ssa";
var helper = {
  toMilliseconds: (s) => {
    const match = /^\s*(\d+:)?(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(s);
    if (!match) {
      throw new Error(`Invalid time format: ${s}`);
    }
    const hh = match[1] ? parseInt(match[1].replace(":", "")) : 0;
    const mm = parseInt(match[2]);
    const ss = parseInt(match[3]);
    const ff = match[4] ? parseInt(match[4]) : 0;
    const ms = hh * 3600 * 1e3 + mm * 60 * 1e3 + ss * 1e3 + ff * 10;
    return ms;
  },
  toTimeString: (ms) => {
    const hh = Math.floor(ms / 1e3 / 3600);
    const mm = Math.floor(ms / 1e3 / 60 % 60);
    const ss = Math.floor(ms / 1e3 % 60);
    const ff = Math.floor(ms % 1e3 / 10);
    const time = `${hh}:${mm < 10 ? "0" : ""}${mm}:${ss < 10 ? "0" : ""}${ss}.${ff < 10 ? "0" : ""}${ff}`;
    return time;
  }
};
var parse = (content, options) => {
  let meta;
  let columns = null;
  const captions = [];
  const eol = options.eol || "\r\n";
  const parts = content.split(/\r?\n\s*\n/);
  for (let i = 0; i < parts.length; i++) {
    const regex = /^\s*\[([^\]]+)\]\r?\n([\s\S]*)$/;
    const match = regex.exec(parts[i]);
    if (match) {
      const tag = match[1];
      const lines = match[2].split(/\r?\n/);
      for (let l = 0; l < lines.length; l++) {
        const line = lines[l];
        if (/^\s*;/.test(line)) {
          continue;
        }
        const m = /^\s*([^\s:]+):\s*(.*)$/.exec(line);
        if (!m) {
          continue;
        }
        if (tag === "Script Info") {
          if (!meta) {
            meta = {};
            meta.type = "meta";
            meta.data = {};
            captions.push(meta);
          }
          if (typeof meta.data === "object") {
            const name = m[1].trim();
            const value = m[2].trim();
            meta.data[name] = value;
          } else {
            throw new Error(`Invalid meta data: ${line}`);
          }
        } else if (tag === "V4 Styles" || tag === "V4+ Styles") {
          const name = m[1].trim();
          const value = m[2].trim();
          if (name === "Format") {
            columns = value.split(/\s*,\s*/g);
          } else if (name === "Style" && columns) {
            const values = value.split(/\s*,\s*/g);
            const caption = {};
            caption.type = "style";
            caption.data = {};
            for (let c = 0; c < columns.length && c < values.length; c++) {
              caption.data[columns[c]] = values[c];
            }
            captions.push(caption);
          }
        } else if (tag === "Events") {
          const name = m[1].trim();
          const value = m[2].trim();
          if (name === "Format") {
            columns = value.split(/\s*,\s*/g);
          } else if (name === "Dialogue" && columns) {
            const values = value.split(/\s*,\s*/g);
            const caption = {};
            caption.type = "caption";
            caption.data = {};
            for (let c = 0; c < columns.length && c < values.length; c++) {
              caption.data[columns[c]] = values[c];
            }
            caption.start = helper.toMilliseconds(caption.data.Start);
            caption.end = helper.toMilliseconds(caption.data.End);
            caption.duration = caption.end - caption.start;
            caption.content = caption.data.Text;
            const getPosition = (s, search, index) => {
              return s.split(search, index).join(search).length;
            };
            const indexOfText = getPosition(value, ",", columns.length - 1) + 1;
            caption.content = value.substring(indexOfText);
            caption.data.Text = caption.content;
            caption.text = caption.content.replace(/\\N/g, eol).replace(/\{[^}]+\}/g, "");
            captions.push(caption);
          }
        }
      }
    }
    if (options.verbose) {
      console.log("WARN: Unknown part", parts[i]);
    }
  }
  return captions;
};
var build = (captions, options) => {
  const eol = options.eol || "\r\n";
  const ass = options.format === "ass";
  let content = "";
  content += `[Script Info]${eol}`;
  content += `; Script generated by subsrt ${eol}`;
  content += `ScriptType: v4.00${ass ? "+" : ""}${eol}`;
  content += `Collisions: Normal${eol}`;
  content += eol;
  if (ass) {
    content += `[V4+ Styles]${eol}`;
    content += `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding${eol}`;
    content += `Style: DefaultVCD, Arial,28,&H00B4FCFC,&H00B4FCFC,&H00000008,&H80000008,-1,0,0,0,100,100,0.00,0.00,1,1.00,2.00,2,30,30,30,0${eol}`;
  } else {
    content += `[V4 Styles]${eol}`;
    content += `Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding${eol}`;
    content += `Style: DefaultVCD, Arial,28,11861244,11861244,11861244,-2147483640,-1,0,1,1,2,2,30,30,30,0,0${eol}`;
  }
  content += eol;
  content += `[Events]${eol}`;
  content += `Format: ${ass ? "Layer" : "Marked"}, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text${eol}`;
  for (let i = 0; i < captions.length; i++) {
    const caption = captions[i];
    if (caption.type === "meta") {
      continue;
    }
    if (!caption.type || caption.type === "caption") {
      content += `Dialogue: ${ass ? "0" : "Marked=0"},${helper.toTimeString(caption.start)},${helper.toTimeString(caption.end)},DefaultVCD, NTP,0000,0000,0000,,${caption.text.replace(/\r?\n/g, "\\N")}${eol}`;
      continue;
    }
    if (options.verbose) {
      console.log("SKIP:", caption);
    }
  }
  return content;
};
var detect = (content) => {
  if (/^\s*\[Script Info\]\r?\n/.test(content) && /\s*\[Events\]\r?\n/.test(content)) {
    return content.indexOf("[V4+ Styles]") > 0 ? "ass" : "ssa";
  }
  return false;
};
var ssa_default = buildHandler({ name: FORMAT_NAME, build, detect, helper, parse });

// node_modules/subsrt-ts/dist/format/ass.js
var FORMAT_NAME2 = "ass";
var ass_default = buildHandler({ name: FORMAT_NAME2, build, detect, helper, parse });

// node_modules/subsrt-ts/dist/format/json.js
var FORMAT_NAME3 = "json";
var parse2 = (content, _options) => JSON.parse(content);
var build2 = (captions, _options) => JSON.stringify(captions, void 0, 2);
var detect2 = (content) => {
  try {
    const res = JSON.parse(content);
    return Array.isArray(res) && res.length > 0 && typeof res[0] === "object";
  } catch (e) {
    return false;
  }
};
var json_default = buildHandler({ name: FORMAT_NAME3, build: build2, detect: detect2, parse: parse2 });

// node_modules/subsrt-ts/dist/format/lrc.js
var FORMAT_NAME4 = "lrc";
var helper2 = {
  toMilliseconds: (s) => {
    const match = /^\s*(\d+):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(s);
    if (!match) {
      throw new Error(`Invalid time format: ${s}`);
    }
    const mm = parseInt(match[1]);
    const ss = parseInt(match[2]);
    const ff = match[3] ? parseInt(match[3]) : 0;
    const ms = mm * 60 * 1e3 + ss * 1e3 + ff * 10;
    return ms;
  },
  toTimeString: (ms) => {
    const mm = Math.floor(ms / 1e3 / 60);
    const ss = Math.floor(ms / 1e3 % 60);
    const ff = Math.floor(ms % 1e3);
    const time = `${(mm < 10 ? "0" : "") + mm}:${ss < 10 ? "0" : ""}${ss}.${ff < 100 ? "0" : ""}${ff < 10 ? "0" : Math.floor(ff / 10)}`;
    return time;
  }
};
var parse3 = (content, options) => {
  let prev = null;
  const captions = [];
  const parts = content.split(/\r?\n/);
  for (let i = 0; i < parts.length; i++) {
    if (!parts[i] || parts[i].trim().length === 0) {
      continue;
    }
    const regex = /^\[(\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\](.*)(?:\r?\n)*$/;
    const match = regex.exec(parts[i]);
    if (match) {
      const caption = {};
      caption.type = "caption";
      caption.start = helper2.toMilliseconds(match[1]);
      caption.end = caption.start + 2e3;
      caption.duration = caption.end - caption.start;
      caption.content = match[2];
      caption.text = caption.content;
      captions.push(caption);
      if (prev) {
        prev.end = caption.start;
        prev.duration = prev.end - prev.start;
      }
      prev = caption;
      continue;
    }
    const meta = /^\[(\w+):([^\]]*)\](?:\r?\n)*$/.exec(parts[i]);
    if (meta) {
      const caption = {};
      caption.type = "meta";
      caption.tag = meta[1];
      if (meta[2]) {
        caption.data = meta[2];
      }
      captions.push(caption);
      continue;
    }
    if (options.verbose) {
      console.log("WARN: Unknown part", parts[i]);
    }
  }
  return captions;
};
var build3 = (captions, options) => {
  let content = "";
  let lyrics = false;
  const eol = options.eol || "\r\n";
  for (let i = 0; i < captions.length; i++) {
    const caption = captions[i];
    if (caption.type === "meta") {
      if (caption.tag && caption.data && typeof caption.data === "string") {
        content += `[${caption.tag}:${caption.data.replace(/[\r\n]+/g, " ")}]${eol}`;
      }
      continue;
    }
    if (!caption.type || caption.type === "caption") {
      if (!lyrics) {
        content += eol;
        lyrics = true;
      }
      content += `[${helper2.toTimeString(caption.start)}]${caption.text}${eol}`;
      continue;
    }
    if (options.verbose) {
      console.log("SKIP:", caption);
    }
  }
  return content;
};
var detect3 = (content) => {
  return /\r?\n\[\d+:\d{1,2}(?:[.,]\d{1,3})?\].*\r?\n/.test(content);
};
var lrc_default = buildHandler({ name: FORMAT_NAME4, build: build3, detect: detect3, helper: helper2, parse: parse3 });

// node_modules/subsrt-ts/dist/format/sbv.js
var FORMAT_NAME5 = "sbv";
var helper3 = {
  toMilliseconds: (s) => {
    const match = /^\s*(\d{1,2}):(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(s);
    if (!match) {
      throw new Error(`Invalid time format: ${s}`);
    }
    const hh = parseInt(match[1]);
    const mm = parseInt(match[2]);
    const ss = parseInt(match[3]);
    const ff = match[4] ? parseInt(match[4]) : 0;
    const ms = hh * 3600 * 1e3 + mm * 60 * 1e3 + ss * 1e3 + ff;
    return ms;
  },
  toTimeString: (ms) => {
    const hh = Math.floor(ms / 1e3 / 3600);
    const mm = Math.floor(ms / 1e3 / 60 % 60);
    const ss = Math.floor(ms / 1e3 % 60);
    const ff = Math.floor(ms % 1e3);
    const time = `${(hh < 10 ? "0" : "") + hh}:${mm < 10 ? "0" : ""}${mm}:${ss < 10 ? "0" : ""}${ss}.${ff < 100 ? "0" : ""}${ff < 10 ? "0" : ""}${ff}`;
    return time;
  }
};
var parse4 = (content, options) => {
  const captions = [];
  const eol = options.eol || "\r\n";
  const parts = content.split(/\r?\n\s*\n/);
  for (let i = 0; i < parts.length; i++) {
    const regex = /^(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\s*[,;]\s*(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\r?\n([\s\S]*)$/;
    const match = regex.exec(parts[i]);
    if (match) {
      const caption = {};
      caption.type = "caption";
      caption.start = helper3.toMilliseconds(match[1]);
      caption.end = helper3.toMilliseconds(match[2]);
      caption.duration = caption.end - caption.start;
      const lines = match[3].split(/\[br\]|\r?\n/gi);
      caption.content = lines.join(eol);
      caption.text = caption.content.replace(/>>[^:]+:\s*/g, "");
      captions.push(caption);
      continue;
    }
    if (options.verbose) {
      console.log("WARN: Unknown part", parts[i]);
    }
  }
  return captions;
};
var build4 = (captions, options) => {
  let content = "";
  const eol = options.eol || "\r\n";
  for (let i = 0; i < captions.length; i++) {
    const caption = captions[i];
    if (!caption.type || caption.type === "caption") {
      content += `${helper3.toTimeString(caption.start)},${helper3.toTimeString(caption.end)}${eol}`;
      content += caption.text + eol;
      content += eol;
      continue;
    }
    if (options.verbose) {
      console.log("SKIP:", caption);
    }
  }
  return content;
};
var detect4 = (content) => {
  return /\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?\s*[,;]\s*\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?/.test(content);
};
var sbv_default = buildHandler({ name: FORMAT_NAME5, build: build4, detect: detect4, helper: helper3, parse: parse4 });

// node_modules/subsrt-ts/dist/format/smi.js
var FORMAT_NAME6 = "smi";
var helper4 = {
  htmlEncode: (text) => text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n/g, "<BR>"),
  htmlDecode: (html, eol) => html.replace(/<BR\s*\/?>/gi, eol || "\r\n").replace(/&nbsp;/g, " ").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")
};
var parse5 = (content, options) => {
  if (options.format && options.format !== FORMAT_NAME6) {
    throw new Error(`Invalid format: ${options.format}`);
  }
  const captions = [];
  const eol = options.eol || "\r\n";
  const title = /<TITLE[^>]*>([\s\S]*)<\/TITLE>/i.exec(content);
  if (title) {
    const caption = {};
    caption.type = "meta";
    caption.name = "title";
    caption.data = title[1].replace(/^\s*/g, "").replace(/\s*$/g, "");
    captions.push(caption);
  }
  const style = /<STYLE[^>]*>([\s\S]*)<\/STYLE>/i.exec(content);
  if (style) {
    const caption = {};
    caption.type = "meta";
    caption.name = "style";
    caption.data = style[1];
    captions.push(caption);
  }
  const sami = content.replace(/^[\s\S]*<BODY[^>]*>/gi, "").replace(/<\/BODY[^>]*>[\s\S]*$/gi, "");
  let prev = null;
  const parts = sami.split(/<SYNC/gi);
  for (let i = 0; i < parts.length; i++) {
    if (!parts[i] || parts[i].trim().length === 0) {
      continue;
    }
    const part = `<SYNC${parts[i]}`;
    const match = /^<SYNC[^>]+Start\s*=\s*["']?(\d+)[^\d>]*>([\s\S]*)/i.exec(part);
    if (match) {
      const caption = {};
      caption.type = "caption";
      caption.start = parseInt(match[1]);
      caption.end = caption.start + 2e3;
      caption.duration = caption.end - caption.start;
      caption.content = match[2].replace(/^<\/SYNC[^>]*>/gi, "");
      let blank = true;
      const p = /^<P.+Class\s*=\s*["']?([\w-]+)(?: .*)?>([\s\S]*)/i.exec(caption.content) || /^<P([^>]*)>([\s\S]*)/i.exec(caption.content);
      if (p) {
        let html = p[2].replace(/<P[\s\S]+$/gi, "");
        html = html.replace(/<BR\s*\/?>\s+/gi, eol).replace(/<BR\s*\/?>/gi, eol).replace(/<[^>]+>/g, "");
        html = html.replace(/^\s+/g, "").replace(/\s+$/g, "");
        blank = html.replace(/&nbsp;/gi, " ").replace(/\s+/g, "").length === 0;
        caption.text = helper4.htmlDecode(html, eol);
      }
      if (!options.preserveSpaces && blank) {
        if (options.verbose) {
          console.log(`INFO: Skipping white space caption at ${caption.start}`);
        }
      } else {
        captions.push(caption);
      }
      if (prev) {
        prev.end = caption.start;
        prev.duration = prev.end - prev.start;
      }
      prev = caption;
      continue;
    }
    if (options.verbose) {
      console.log("WARN: Unknown part", parts[i]);
    }
  }
  return captions;
};
var build5 = (captions, options) => {
  const eol = options.eol || "\r\n";
  let content = "";
  content += `<SAMI>${eol}`;
  content += `<HEAD>${eol}`;
  content += `<TITLE>${options.title || ""}</TITLE>${eol}`;
  content += `<STYLE TYPE="text/css">${eol}`;
  content += `<!--${eol}`;
  content += `P { font-family: Arial; font-weight: normal; color: white; background-color: black; text-align: center; }${eol}`;
  content += `.LANG { Name: ${options.langName || "English"}; lang: ${options.langCode || "en-US"}; SAMIType: CC; }${eol}`;
  content += `-->${eol}`;
  content += `</STYLE>${eol}`;
  content += `</HEAD>${eol}`;
  content += `<BODY>${eol}`;
  for (let i = 0; i < captions.length; i++) {
    const caption = captions[i];
    if (caption.type === "meta") {
      continue;
    }
    if (!caption.type || caption.type === "caption") {
      content += `<SYNC Start=${caption.start}>${eol}`;
      content += `  <P Class=LANG>${helper4.htmlEncode(caption.text || "")}${options.closeTags ? "</P>" : ""}${eol}`;
      if (options.closeTags) {
        content += `</SYNC>${eol}`;
      }
      content += `<SYNC Start=${caption.end}>${eol}`;
      content += `  <P Class=LANG>&nbsp;${options.closeTags ? "</P>" : ""}${eol}`;
      if (options.closeTags) {
        content += `</SYNC>${eol}`;
      }
      continue;
    }
    if (options.verbose) {
      console.log("SKIP:", caption);
    }
  }
  content += `</BODY>${eol}`;
  content += `</SAMI>${eol}`;
  return content;
};
var detect5 = (content) => {
  return /<SAMI[^>]*>[\s\S]*<BODY[^>]*>/.test(content);
};
var smi_default = buildHandler({ name: FORMAT_NAME6, build: build5, detect: detect5, helper: helper4, parse: parse5 });

// node_modules/subsrt-ts/dist/format/srt.js
var FORMAT_NAME7 = "srt";
var helper5 = {
  toMilliseconds: (s) => {
    const match = /^\s*(\d{1,2}):(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(s);
    if (!match) {
      throw new Error(`Invalid time format: ${s}`);
    }
    const hh = parseInt(match[1]);
    const mm = parseInt(match[2]);
    const ss = parseInt(match[3]);
    const ff = match[4] ? parseInt(match[4]) : 0;
    const ms = hh * 3600 * 1e3 + mm * 60 * 1e3 + ss * 1e3 + ff;
    return ms;
  },
  toTimeString: (ms) => {
    const hh = Math.floor(ms / 1e3 / 3600);
    const mm = Math.floor(ms / 1e3 / 60 % 60);
    const ss = Math.floor(ms / 1e3 % 60);
    const ff = Math.floor(ms % 1e3);
    const time = `${(hh < 10 ? "0" : "") + hh}:${mm < 10 ? "0" : ""}${mm}:${ss < 10 ? "0" : ""}${ss},${ff < 100 ? "0" : ""}${ff < 10 ? "0" : ""}${ff}`;
    return time;
  }
};
var parse6 = (content, options) => {
  const captions = [];
  const eol = options.eol || "\r\n";
  const parts = content.split(/\r?\n\s*\n/g);
  for (let i = 0; i < parts.length; i++) {
    const regex = /^(\d+)\r?\n(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\s*-->\s*(\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\r?\n([\s\S]*)$/;
    const match = regex.exec(parts[i]);
    if (match) {
      const caption = {};
      caption.type = "caption";
      caption.index = parseInt(match[1]);
      caption.start = helper5.toMilliseconds(match[2]);
      caption.end = helper5.toMilliseconds(match[3]);
      caption.duration = caption.end - caption.start;
      const lines = match[4].split(/\r?\n/);
      caption.content = lines.join(eol);
      caption.text = caption.content.replace(/<[^>]+>/g, "").replace(/\{[^}]+\}/g, "").replace(/>>[^:]*:\s*/g, "");
      captions.push(caption);
      continue;
    }
    if (options.verbose) {
      console.log("WARN: Unknown part", parts[i]);
    }
  }
  return captions;
};
var build6 = (captions, options) => {
  let srt = "";
  const eol = options.eol || "\r\n";
  for (let i = 0; i < captions.length; i++) {
    const caption = captions[i];
    if (!caption.type || caption.type === "caption") {
      srt += (i + 1).toString() + eol;
      srt += `${helper5.toTimeString(caption.start)} --> ${helper5.toTimeString(caption.end)}${eol}`;
      srt += caption.text + eol;
      srt += eol;
      continue;
    }
    if (options.verbose) {
      console.log("SKIP:", caption);
    }
  }
  return srt;
};
var detect6 = (content) => {
  return /\d+\r?\n\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?\s*-->\s*\d{1,2}:\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?/.test(content);
};
var srt_default = buildHandler({ name: FORMAT_NAME7, build: build6, detect: detect6, helper: helper5, parse: parse6 });

// node_modules/subsrt-ts/dist/format/sub.js
var FORMAT_NAME8 = "sub";
var DEFAULT_FPS = 25;
var parse7 = (content, options) => {
  options.fps || (options.fps = DEFAULT_FPS);
  const fps = options.fps > 0 ? options.fps : DEFAULT_FPS;
  const captions = [];
  const eol = options.eol || "\r\n";
  const parts = content.split(/\r?\n/g);
  for (let i = 0; i < parts.length; i++) {
    const regex = /^\{(\d+)\}\{(\d+)\}(.*)$/;
    const match = regex.exec(parts[i]);
    if (match) {
      const caption = {};
      caption.type = "caption";
      caption.index = i + 1;
      caption.frame = {
        start: parseInt(match[1]),
        end: parseInt(match[2]),
        count: parseInt(match[2]) - parseInt(match[1])
      };
      caption.start = Math.round(caption.frame.start / fps);
      caption.end = Math.round(caption.frame.end / fps);
      caption.duration = caption.end - caption.start;
      const lines = match[3].split(/\|/g);
      caption.content = lines.join(eol);
      caption.text = caption.content.replace(/\{[^}]+\}/g, "");
      captions.push(caption);
      continue;
    }
    if (options.verbose) {
      console.log("WARN: Unknown part", parts[i]);
    }
  }
  return captions;
};
var build7 = (captions, options) => {
  const fps = (options.fps || 0) > 0 ? options.fps : DEFAULT_FPS;
  let sub = "";
  const eol = options.eol || "\r\n";
  for (let i = 0; i < captions.length; i++) {
    const caption = captions[i];
    if (!caption.type || caption.type === "caption") {
      const startFrame = typeof caption.frame === "object" && caption.frame.start >= 0 ? caption.frame.start : caption.start * fps;
      const endFrame = typeof caption.frame === "object" && caption.frame.end >= 0 ? caption.frame.end : caption.end * fps;
      const text = caption.text.replace(/\r?\n/, "|");
      sub += `{${startFrame}}{${endFrame}}${text}${eol}`;
      continue;
    }
    if (options.verbose) {
      console.log("SKIP:", caption);
    }
  }
  return sub;
};
var detect7 = (content) => {
  return /^\{\d+\}\{\d+\}.*/.test(content);
};
var sub_default = buildHandler({ name: FORMAT_NAME8, build: build7, detect: detect7, parse: parse7 });

// node_modules/subsrt-ts/dist/format/vtt.js
var FORMAT_NAME9 = "vtt";
var helper6 = {
  toMilliseconds: (s) => {
    const match = /^\s*(\d{1,2}:)?(\d{1,2}):(\d{1,2})(?:[.,](\d{1,3}))?\s*$/.exec(s);
    if (!match) {
      throw new Error(`Invalid time format: ${s}`);
    }
    const hh = match[1] ? parseInt(match[1].replace(":", "")) : 0;
    const mm = parseInt(match[2]);
    const ss = parseInt(match[3]);
    const ff = match[4] ? parseInt(match[4]) : 0;
    const ms = hh * 3600 * 1e3 + mm * 60 * 1e3 + ss * 1e3 + ff;
    return ms;
  },
  toTimeString: (ms) => {
    const hh = Math.floor(ms / 1e3 / 3600);
    const mm = Math.floor(ms / 1e3 / 60 % 60);
    const ss = Math.floor(ms / 1e3 % 60);
    const ff = Math.floor(ms % 1e3);
    const time = `${(hh < 10 ? "0" : "") + hh}:${mm < 10 ? "0" : ""}${mm}:${ss < 10 ? "0" : ""}${ss}.${ff < 100 ? "0" : ""}${ff < 10 ? "0" : ""}${ff}`;
    return time;
  }
};
var parse8 = (content, options) => {
  let index = 1;
  const captions = [];
  const parts = content.split(/\r?\n\s*\n/);
  for (const part of parts) {
    const regex = /^([^\r\n]+\r?\n)?((?:\d{1,2}:)?\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)\s*-->\s*((?:\d{1,2}:)?\d{1,2}:\d{1,2}(?:[.,]\d{1,3})?)[^\S\r\n]?.*\r?\n([\s\S]*)$/;
    const match = regex.exec(part);
    if (match) {
      const caption = {};
      caption.type = "caption";
      caption.index = index++;
      if (match[1]) {
        caption.cue = match[1].replace(/[\r\n]*/g, "");
      }
      caption.start = helper6.toMilliseconds(match[2]);
      caption.end = helper6.toMilliseconds(match[3]);
      caption.duration = caption.end - caption.start;
      caption.content = match[4];
      caption.text = caption.content.replace(/<[^>]+>/g, "").replace(/\{[^}]+\}/g, "");
      captions.push(caption);
      continue;
    }
    const meta = /^([A-Z]+)(\r?\n([\s\S]*))?$/.exec(part) || /^([A-Z]+)\s+([^\r\n]*)$/.exec(part);
    if (meta) {
      const caption = {};
      caption.type = "meta";
      caption.name = meta[1];
      if (meta[3]) {
        caption.data = meta[3];
      }
      captions.push(caption);
      continue;
    }
    if (options.verbose) {
      console.log("WARN: Unknown part", part);
    }
  }
  return captions;
};
var build8 = (captions, options) => {
  const eol = options.eol || "\r\n";
  let content = `WEBVTT${eol}${eol}`;
  for (let i = 0; i < captions.length; i++) {
    const caption = captions[i];
    if (caption.type === "meta") {
      if (caption.name === "WEBVTT") {
        continue;
      }
      content += caption.name + eol;
      content += caption.data ? caption.data + eol : "";
      content += eol;
      continue;
    }
    if (!caption.type || caption.type === "caption") {
      content += (i + 1).toString() + eol;
      content += `${helper6.toTimeString(caption.start)} --> ${helper6.toTimeString(caption.end)}${eol}`;
      content += caption.text + eol;
      content += eol;
      continue;
    }
    if (options.verbose) {
      console.log("SKIP:", caption);
    }
  }
  return content;
};
var detect8 = (content) => {
  return /^\s*WEBVTT\r?\n/.test(content);
};
var vtt_default = buildHandler({ name: FORMAT_NAME9, build: build8, detect: detect8, helper: helper6, parse: parse8 });

// node_modules/subsrt-ts/dist/format/index.js
var formats = {
  vtt: vtt_default,
  lrc: lrc_default,
  smi: smi_default,
  ssa: ssa_default,
  ass: ass_default,
  sub: sub_default,
  srt: srt_default,
  sbv: sbv_default,
  json: json_default
};
var format_default = formats;

// node_modules/subsrt-ts/dist/subsrt.js
var clone = (obj) => JSON.parse(JSON.stringify(obj));
var Subsrt = class {
  constructor() {
    this.format = format_default;
    this.list = () => Object.keys(this.format);
    this.detect = (content) => {
      const formats2 = this.list();
      for (let i = 0; i < formats2.length; i++) {
        const f = formats2[i];
        const handler = this.format[f];
        if (typeof handler === "undefined") {
          continue;
        }
        if (typeof handler.detect !== "function") {
          continue;
        }
        const d = handler.detect(content);
        if (d === true || d === f) {
          return f;
        }
      }
      return "";
    };
    this.parse = (content, options = {}) => {
      const format2 = options.format || this.detect(content);
      if (!format2 || format2.trim().length === 0) {
        throw new Error("Cannot determine subtitle format!");
      }
      const handler = this.format[format2];
      if (typeof handler === "undefined") {
        throw new Error(`Unsupported subtitle format: ${format2}`);
      }
      const func = handler.parse;
      if (typeof func !== "function") {
        throw new Error(`Subtitle format does not support 'parse' op: ${format2}`);
      }
      return func(content, options);
    };
    this.build = (captions, options = {}) => {
      const format2 = options.format || "srt";
      if (!format2 || format2.trim().length === 0) {
        throw new Error("Cannot determine subtitle format!");
      }
      const handler = this.format[format2];
      if (typeof handler === "undefined") {
        throw new Error(`Unsupported subtitle format: ${format2}`);
      }
      const func = handler.build;
      if (typeof func !== "function") {
        throw new Error(`Subtitle format does not support 'build' op: ${format2}`);
      }
      return func(captions, options);
    };
    this.convert = (content, _options = {}) => {
      let options = {};
      if (typeof _options === "string") {
        options.to = _options;
      } else {
        options = _options;
      }
      const parseOptions = {
        format: options.from || void 0,
        verbose: options.verbose,
        eol: options.eol
      };
      let captions = this.parse(content, parseOptions);
      if (options.resync) {
        captions = this.resync(captions, options.resync);
      }
      const buildOptions = {
        format: options.to || options.format,
        verbose: options.verbose,
        eol: options.eol
      };
      const result = this.build(captions, buildOptions);
      return result;
    };
    this.resync = (captions, options = {}) => {
      let func, ratio, frame = false, offset;
      if (typeof options === "function") {
        func = options;
      } else if (typeof options === "number") {
        offset = options;
        func = (a) => [a[0] + offset, a[1] + offset];
      } else if (typeof options === "object") {
        offset = (options.offset || 0) * (options.frame ? options.fps || 25 : 1);
        ratio = options.ratio || 1;
        frame = options.frame || false;
        func = (a) => [Math.round(a[0] * ratio + offset), Math.round(a[1] * ratio + offset)];
      } else {
        throw new Error("Argument 'options' not defined!");
      }
      const resynced = [];
      for (let i = 0; i < captions.length; i++) {
        const caption = clone(captions[i]);
        if (!caption.type || caption.type === "caption") {
          if (frame) {
            const shift = func([caption.frame.start, caption.frame.end]);
            if (shift && shift.length === 2) {
              caption.frame.start = shift[0];
              caption.frame.end = shift[1];
              caption.frame.count = caption.frame.end - caption.frame.start;
            }
          } else {
            const shift = func([caption.start, caption.end]);
            if (shift && shift.length === 2) {
              caption.start = shift[0];
              caption.end = shift[1];
              caption.duration = caption.end - caption.start;
            }
          }
        }
        resynced.push(caption);
      }
      return resynced;
    };
  }
};
var subsrt = new Subsrt();
var subsrt_default = subsrt;
var { format, list, detect: detect9, parse: parse9, build: build9, convert, resync } = subsrt;
export {
  build9 as build,
  convert,
  subsrt_default as default,
  detect9 as detect,
  format,
  list,
  parse9 as parse,
  resync
};
//# sourceMappingURL=subsrt-ts.js.map
