import {
  require_engine_is_node,
  require_validate_arguments_length
} from "./chunk-3KBQEVSC.js";
import {
  require_create_property,
  require_is_constructor,
  require_iterators
} from "./chunk-IIJ2FYC7.js";
import {
  require_classof
} from "./chunk-3C36ZEHD.js";
import {
  require_function_bind_context
} from "./chunk-IQHEENQG.js";
import {
  require_export
} from "./chunk-G6PODNB4.js";
import {
  require_length_of_array_like
} from "./chunk-RCSXG2HZ.js";
import {
  require_a_callable,
  require_an_object,
  require_create_non_enumerable_property,
  require_create_property_descriptor,
  require_engine_v8_version,
  require_fails,
  require_function_call,
  require_function_uncurry_this,
  require_get_built_in,
  require_get_method,
  require_global,
  require_has_own_property,
  require_is_callable,
  require_is_null_or_undefined,
  require_is_object,
  require_is_pure,
  require_is_symbol,
  require_object_is_prototype_of,
  require_try_to_string,
  require_uid,
  require_well_known_symbol
} from "./chunk-U3I62X7R.js";
import {
  __commonJS
} from "./chunk-WQG2LZMB.js";

// node_modules/core-js/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it) {
      if (!isNullOrUndefined(it))
        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/internals/get-iterator.js"(exports, module) {
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js/internals/iterator-close.js"(exports, module) {
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js/internals/iterate.js"(exports, module) {
    var bind = require_function_bind_context();
    var call = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result))
              return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js/internals/regexp-flags.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    module.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
    var call = require_function_call();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlags = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(R) {
      var flags = R.flags;
      return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
    };
  }
});

// node_modules/core-js/internals/map-helpers.js
var require_map_helpers = __commonJS({
  "node_modules/core-js/internals/map-helpers.js"(exports, module) {
    var uncurryThis = require_function_uncurry_this();
    var MapPrototype = Map.prototype;
    module.exports = {
      // eslint-disable-next-line es/no-map -- safe
      Map,
      set: uncurryThis(MapPrototype.set),
      get: uncurryThis(MapPrototype.get),
      has: uncurryThis(MapPrototype.has),
      remove: uncurryThis(MapPrototype["delete"]),
      proto: MapPrototype
    };
  }
});

// node_modules/core-js/internals/set-helpers.js
var require_set_helpers = __commonJS({
  "node_modules/core-js/internals/set-helpers.js"(exports, module) {
    var uncurryThis = require_function_uncurry_this();
    var SetPrototype = Set.prototype;
    module.exports = {
      // eslint-disable-next-line es/no-set -- safe
      Set,
      add: uncurryThis(SetPrototype.add),
      has: uncurryThis(SetPrototype.has),
      remove: uncurryThis(SetPrototype["delete"]),
      proto: SetPrototype
    };
  }
});

// node_modules/core-js/internals/error-stack-installable.js
var require_error_stack_installable = __commonJS({
  "node_modules/core-js/internals/error-stack-installable.js"(exports, module) {
    var fails = require_fails();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = !fails(function() {
      var error = Error("a");
      if (!("stack" in error))
        return true;
      Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
      return error.stack !== 7;
    });
  }
});

// node_modules/core-js/internals/engine-is-deno.js
var require_engine_is_deno = __commonJS({
  "node_modules/core-js/internals/engine-is-deno.js"(exports, module) {
    module.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
  }
});

// node_modules/core-js/internals/engine-is-browser.js
var require_engine_is_browser = __commonJS({
  "node_modules/core-js/internals/engine-is-browser.js"(exports, module) {
    var IS_DENO = require_engine_is_deno();
    var IS_NODE = require_engine_is_node();
    module.exports = !IS_DENO && !IS_NODE && typeof window == "object" && typeof document == "object";
  }
});

// node_modules/core-js/internals/structured-clone-proper-transfer.js
var require_structured_clone_proper_transfer = __commonJS({
  "node_modules/core-js/internals/structured-clone-proper-transfer.js"(exports, module) {
    var global = require_global();
    var fails = require_fails();
    var V8 = require_engine_v8_version();
    var IS_BROWSER = require_engine_is_browser();
    var IS_DENO = require_engine_is_deno();
    var IS_NODE = require_engine_is_node();
    var structuredClone = global.structuredClone;
    module.exports = !!structuredClone && !fails(function() {
      if (IS_DENO && V8 > 92 || IS_NODE && V8 > 94 || IS_BROWSER && V8 > 97)
        return false;
      var buffer = new ArrayBuffer(8);
      var clone = structuredClone(buffer, { transfer: [buffer] });
      return buffer.byteLength != 0 || clone.byteLength != 8;
    });
  }
});

// node_modules/core-js/modules/web.structured-clone.js
var require_web_structured_clone = __commonJS({
  "node_modules/core-js/modules/web.structured-clone.js"() {
    var IS_PURE = require_is_pure();
    var $ = require_export();
    var global = require_global();
    var getBuiltin = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var uid = require_uid();
    var isCallable = require_is_callable();
    var isConstructor = require_is_constructor();
    var isNullOrUndefined = require_is_null_or_undefined();
    var isObject = require_is_object();
    var isSymbol = require_is_symbol();
    var iterate = require_iterate();
    var anObject = require_an_object();
    var classof = require_classof();
    var hasOwn = require_has_own_property();
    var createProperty = require_create_property();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var lengthOfArrayLike = require_length_of_array_like();
    var validateArgumentsLength = require_validate_arguments_length();
    var getRegExpFlags = require_regexp_get_flags();
    var MapHelpers = require_map_helpers();
    var SetHelpers = require_set_helpers();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var PROPER_TRANSFER = require_structured_clone_proper_transfer();
    var Object2 = global.Object;
    var Array2 = global.Array;
    var Date = global.Date;
    var Error2 = global.Error;
    var EvalError = global.EvalError;
    var RangeError = global.RangeError;
    var ReferenceError = global.ReferenceError;
    var SyntaxError = global.SyntaxError;
    var TypeError2 = global.TypeError;
    var URIError = global.URIError;
    var PerformanceMark = global.PerformanceMark;
    var WebAssembly = global.WebAssembly;
    var CompileError = WebAssembly && WebAssembly.CompileError || Error2;
    var LinkError = WebAssembly && WebAssembly.LinkError || Error2;
    var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error2;
    var DOMException = getBuiltin("DOMException");
    var Map2 = MapHelpers.Map;
    var mapHas = MapHelpers.has;
    var mapGet = MapHelpers.get;
    var mapSet = MapHelpers.set;
    var Set2 = SetHelpers.Set;
    var setAdd = SetHelpers.add;
    var objectKeys = getBuiltin("Object", "keys");
    var push = uncurryThis([].push);
    var thisBooleanValue = uncurryThis(true.valueOf);
    var thisNumberValue = uncurryThis(1 .valueOf);
    var thisStringValue = uncurryThis("".valueOf);
    var thisTimeValue = uncurryThis(Date.prototype.getTime);
    var PERFORMANCE_MARK = uid("structuredClone");
    var DATA_CLONE_ERROR = "DataCloneError";
    var TRANSFERRING = "Transferring";
    var checkBasicSemantic = function(structuredCloneImplementation) {
      return !fails(function() {
        var set1 = new global.Set([7]);
        var set2 = structuredCloneImplementation(set1);
        var number = structuredCloneImplementation(Object2(7));
        return set2 == set1 || !set2.has(7) || typeof number != "object" || number != 7;
      }) && structuredCloneImplementation;
    };
    var checkErrorsCloning = function(structuredCloneImplementation, $Error) {
      return !fails(function() {
        var error = new $Error();
        var test = structuredCloneImplementation({ a: error, b: error });
        return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);
      });
    };
    var checkNewErrorsCloningSemantic = function(structuredCloneImplementation) {
      return !fails(function() {
        var test = structuredCloneImplementation(new global.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
        return test.name != "AggregateError" || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
      });
    };
    var nativeStructuredClone = global.structuredClone;
    var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error2) || !checkErrorsCloning(nativeStructuredClone, DOMException) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
    var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
      return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
    });
    var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
    var throwUncloneable = function(type) {
      throw new DOMException("Uncloneable type: " + type, DATA_CLONE_ERROR);
    };
    var throwUnpolyfillable = function(type, action) {
      throw new DOMException((action || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
    };
    var createDataTransfer = function() {
      var dataTransfer;
      try {
        dataTransfer = new global.DataTransfer();
      } catch (error) {
        try {
          dataTransfer = new global.ClipboardEvent("").clipboardData;
        } catch (error2) {
        }
      }
      return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;
    };
    var structuredCloneInternal = function(value, map) {
      if (isSymbol(value))
        throwUncloneable("Symbol");
      if (!isObject(value))
        return value;
      if (map) {
        if (mapHas(map, value))
          return mapGet(map, value);
      } else
        map = new Map2();
      var type = classof(value);
      var deep = false;
      var C, name, cloned, dataTransfer, i, length, keys, key, source, target, options;
      switch (type) {
        case "Array":
          cloned = Array2(lengthOfArrayLike(value));
          deep = true;
          break;
        case "Object":
          cloned = {};
          deep = true;
          break;
        case "Map":
          cloned = new Map2();
          deep = true;
          break;
        case "Set":
          cloned = new Set2();
          deep = true;
          break;
        case "RegExp":
          cloned = new RegExp(value.source, getRegExpFlags(value));
          break;
        case "Error":
          name = value.name;
          switch (name) {
            case "AggregateError":
              cloned = getBuiltin("AggregateError")([]);
              break;
            case "EvalError":
              cloned = EvalError();
              break;
            case "RangeError":
              cloned = RangeError();
              break;
            case "ReferenceError":
              cloned = ReferenceError();
              break;
            case "SyntaxError":
              cloned = SyntaxError();
              break;
            case "TypeError":
              cloned = TypeError2();
              break;
            case "URIError":
              cloned = URIError();
              break;
            case "CompileError":
              cloned = CompileError();
              break;
            case "LinkError":
              cloned = LinkError();
              break;
            case "RuntimeError":
              cloned = RuntimeError();
              break;
            default:
              cloned = Error2();
          }
          deep = true;
          break;
        case "DOMException":
          cloned = new DOMException(value.message, value.name);
          deep = true;
          break;
        case "DataView":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          C = global[type];
          if (!isObject(C))
            throwUnpolyfillable(type);
          cloned = new C(
            // this is safe, since arraybuffer cannot have circular references
            structuredCloneInternal(value.buffer, map),
            value.byteOffset,
            type === "DataView" ? value.byteLength : value.length
          );
          break;
        case "DOMQuad":
          try {
            cloned = new DOMQuad(
              structuredCloneInternal(value.p1, map),
              structuredCloneInternal(value.p2, map),
              structuredCloneInternal(value.p3, map),
              structuredCloneInternal(value.p4, map)
            );
          } catch (error) {
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else
              throwUnpolyfillable(type);
          }
          break;
        case "FileList":
          dataTransfer = createDataTransfer();
          if (dataTransfer) {
            for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
              dataTransfer.items.add(structuredCloneInternal(value[i], map));
            }
            cloned = dataTransfer.files;
          } else if (nativeRestrictedStructuredClone) {
            cloned = nativeRestrictedStructuredClone(value);
          } else
            throwUnpolyfillable(type);
          break;
        case "ImageData":
          try {
            cloned = new ImageData(
              structuredCloneInternal(value.data, map),
              value.width,
              value.height,
              { colorSpace: value.colorSpace }
            );
          } catch (error) {
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else
              throwUnpolyfillable(type);
          }
          break;
        default:
          if (nativeRestrictedStructuredClone) {
            cloned = nativeRestrictedStructuredClone(value);
          } else
            switch (type) {
              case "BigInt":
                cloned = Object2(value.valueOf());
                break;
              case "Boolean":
                cloned = Object2(thisBooleanValue(value));
                break;
              case "Number":
                cloned = Object2(thisNumberValue(value));
                break;
              case "String":
                cloned = Object2(thisStringValue(value));
                break;
              case "Date":
                cloned = new Date(thisTimeValue(value));
                break;
              case "ArrayBuffer":
                C = global.DataView;
                if (!C && typeof value.slice != "function")
                  throwUnpolyfillable(type);
                try {
                  if (typeof value.slice == "function" && !value.resizable) {
                    cloned = value.slice(0);
                  } else {
                    length = value.byteLength;
                    options = "maxByteLength" in value ? { maxByteLength: value.maxByteLength } : void 0;
                    cloned = new ArrayBuffer(length, options);
                    source = new C(value);
                    target = new C(cloned);
                    for (i = 0; i < length; i++) {
                      target.setUint8(i, source.getUint8(i));
                    }
                  }
                } catch (error) {
                  throw new DOMException("ArrayBuffer is detached", DATA_CLONE_ERROR);
                }
                break;
              case "SharedArrayBuffer":
                cloned = value;
                break;
              case "Blob":
                try {
                  cloned = value.slice(0, value.size, value.type);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMPoint":
              case "DOMPointReadOnly":
                C = global[type];
                try {
                  cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMRect":
              case "DOMRectReadOnly":
                C = global[type];
                try {
                  cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMMatrix":
              case "DOMMatrixReadOnly":
                C = global[type];
                try {
                  cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "AudioData":
              case "VideoFrame":
                if (!isCallable(value.clone))
                  throwUnpolyfillable(type);
                try {
                  cloned = value.clone();
                } catch (error) {
                  throwUncloneable(type);
                }
                break;
              case "File":
                try {
                  cloned = new File([value], value.name, value);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "CropTarget":
              case "CryptoKey":
              case "FileSystemDirectoryHandle":
              case "FileSystemFileHandle":
              case "FileSystemHandle":
              case "GPUCompilationInfo":
              case "GPUCompilationMessage":
              case "ImageBitmap":
              case "RTCCertificate":
              case "WebAssembly.Module":
                throwUnpolyfillable(type);
              default:
                throwUncloneable(type);
            }
      }
      mapSet(map, value, cloned);
      if (deep)
        switch (type) {
          case "Array":
          case "Object":
            keys = objectKeys(value);
            for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
              key = keys[i];
              createProperty(cloned, key, structuredCloneInternal(value[key], map));
            }
            break;
          case "Map":
            value.forEach(function(v, k) {
              mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
            });
            break;
          case "Set":
            value.forEach(function(v) {
              setAdd(cloned, structuredCloneInternal(v, map));
            });
            break;
          case "Error":
            createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
            if (hasOwn(value, "cause")) {
              createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
            }
            if (name == "AggregateError") {
              cloned.errors = structuredCloneInternal(value.errors, map);
            }
          case "DOMException":
            if (ERROR_STACK_INSTALLABLE) {
              createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
            }
        }
      return cloned;
    };
    var tryToTransfer = function(rawTransfer, map) {
      if (!isObject(rawTransfer))
        throw TypeError2("Transfer option cannot be converted to a sequence");
      var transfer = [];
      iterate(rawTransfer, function(value2) {
        push(transfer, anObject(value2));
      });
      var i = 0;
      var length = lengthOfArrayLike(transfer);
      var value, type, C, transferredArray, transferred, canvas, context;
      if (PROPER_TRANSFER) {
        transferredArray = nativeStructuredClone(transfer, { transfer });
        while (i < length)
          mapSet(map, transfer[i], transferredArray[i++]);
      } else
        while (i < length) {
          value = transfer[i++];
          if (mapHas(map, value))
            throw new DOMException("Duplicate transferable", DATA_CLONE_ERROR);
          type = classof(value);
          switch (type) {
            case "ImageBitmap":
              C = global.OffscreenCanvas;
              if (!isConstructor(C))
                throwUnpolyfillable(type, TRANSFERRING);
              try {
                canvas = new C(value.width, value.height);
                context = canvas.getContext("bitmaprenderer");
                context.transferFromImageBitmap(value);
                transferred = canvas.transferToImageBitmap();
              } catch (error) {
              }
              break;
            case "AudioData":
            case "VideoFrame":
              if (!isCallable(value.clone) || !isCallable(value.close))
                throwUnpolyfillable(type, TRANSFERRING);
              try {
                transferred = value.clone();
                value.close();
              } catch (error) {
              }
              break;
            case "ArrayBuffer":
              if (!isCallable(value.transfer))
                throwUnpolyfillable(type, TRANSFERRING);
              transferred = value.transfer();
              break;
            case "MediaSourceHandle":
            case "MessagePort":
            case "OffscreenCanvas":
            case "ReadableStream":
            case "TransformStream":
            case "WritableStream":
              throwUnpolyfillable(type, TRANSFERRING);
          }
          if (transferred === void 0)
            throw new DOMException("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
          mapSet(map, value, transferred);
        }
    };
    $({ global: true, enumerable: true, sham: !PROPER_TRANSFER, forced: FORCED_REPLACEMENT }, {
      structuredClone: function structuredClone(value) {
        var options = validateArgumentsLength(arguments.length, 1) > 1 && !isNullOrUndefined(arguments[1]) ? anObject(arguments[1]) : void 0;
        var transfer = options ? options.transfer : void 0;
        var map;
        if (transfer !== void 0) {
          map = new Map2();
          tryToTransfer(transfer, map);
        }
        return structuredCloneInternal(value, map);
      }
    });
  }
});

export {
  require_error_stack_installable,
  require_is_array_iterator_method,
  require_get_iterator_method,
  require_get_iterator,
  require_iterator_close,
  require_iterate,
  require_engine_is_deno,
  require_engine_is_browser,
  require_regexp_flags,
  require_regexp_get_flags,
  require_web_structured_clone
};
//# sourceMappingURL=chunk-E53OAPTJ.js.map
